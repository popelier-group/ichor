import json
import re
from pathlib import Path
from typing import Optional, Union

import numpy as np

from ichor import constants, patterns
from ichor.common.functools import (buildermethod, cached_property,
                                    classproperty)
from ichor.common.io import move
from ichor.files.file import File, FileContents
from ichor.files.geometry import GeometryData, GeometryDataFile
from ichor.multipoles import (rotate_dipole, rotate_hexadecapole,
                              rotate_octupole, rotate_quadrupole)


class INT(GeometryDataFile, File):
    """Wraps around one .int file which is generated by AIMALL for every atom in the system.

    :param path: The Path object corresponding to an .int file
    :param parent: An `Atoms` instance which holds the coordinate information for all atoms in the system.
        This information is needed to form the C matrix when rotating multipoles from the global to the local frame.
    """

    def __init__(self, path: Union[Path, str], parent=None):
        File.__init__(self, path)
        GeometryDataFile.__init__(self)

        self.parent = parent

        self.integration_data = FileContents
        self.multipoles_data = FileContents
        self.iqa_data = FileContents
        self.dispersion_data = FileContents

    @classproperty
    def filetype(cls) -> str:
        """Returns the file extension of AIMALL files which are used"""
        return ".int"

    @classproperty
    def rotated_filetype(cls) -> str:
        """Returns the file extension of AIMALL files which are stored as backup files. These backup files are the original AIMALL files,
        which are renamed so that a json file can be written out as .int instead."""
        return ".json"

    @buildermethod
    def _read_file(self):
        """Read an .int file. The first time that the .int file is read successfully, a json file with the
        important information is written in the same directory. This json file has the suffix `.int` from now on
        and the original `.int` file is stored with suffix `.int.bak` for backup."""
        try:
            self.read_json()
        except json.decoder.JSONDecodeError:
            self.read_int()
            self.write_json()

    @property
    def atom_name(self) -> str:
        """Returns the name of the atom, including its index in the molecule. Eg. C1, H2, O3, etc."""
        return self.path.stem.upper()

    @property
    def atom_num(self):
        """Returns the atom index in the system. (1-index)"""
        return int(re.findall("\d+", self.atom_name)[0])

    @property
    def json_path(self) -> Path:
        """ Returns a Path object corresponding to the json file"""
        return self.path.with_suffix(self.rotated_filetype)

    @property
    def file_contents(self):
        """A list of strings that this class should have accessible as attributes"""
        return ["iqa", *constants.multipole_names]

    @property
    def integration_error(self):
        """The integration error can tell you if a point has been decomposed into topological atoms correctly. A large integration error signals
        that the point might not be suitable for training as the AIMALL IQA/multipole moments might be inaccurate."""
        return self.integration_data["L"]

    @property
    def iqa(self):
        """Returns the IQA energy of the topological atom that was calculated for this topological atom (since 1 .int file is written for each topological atom)."""
        # TODO: remove the ADD_DISPERSION. This class should only be used to parse .int files and
        # processing the data should be done somewhere else.
        from ichor.qct import ADD_DISPERSION

        iqa = self.iqa_data["E_IQA(A)"]
        if ADD_DISPERSION():
            iqa += self.dispersion
        return iqa

    @property
    def e_intra(self):
        return self.iqa_data["E_IQA_Intra(A)"]

    @property
    def iqa_dispersion(self):
        return self.iqa + self.dispersion

    @property
    def multipoles(self):
        """Returns a dictionary of the multipole moments that were calculated for this particular topological atom (since 1 .int file is written for each topological atom)."""
        multipoles = {
            multipole: self.multipoles_data[multipole]
            for multipole in constants.multipole_names
        }
        multipoles["q00"] = self.q  # replace charge with net charge
        return multipoles

    @property
    def q(self):
        """Returns the point charge (monopole moment) of the topological atom."""
        return self.integration_data["q"]

    @property
    def q00(self):
        """Returns the point charge (monopole moment) of the topological atom."""
        return self.q

    @property
    def dipole(self):
        """Returns the magnitude of the dipole moment of the topological atom."""
        return np.sqrt(sum([self.q10 ** 2, self.q11c ** 2, self.q11s ** 2]))

    @buildermethod
    def read_int(self):
        """Method used to parse the AIMAll '.int' file"""

        self.integration_data = GeometryData()
        self.iqa_data = GeometryData()
        self.dispersion_data = GeometryData()
        self.multipoles_data = GeometryData()

        with open(self.path, "r") as f:
            for line in f:
                """
                Following this line, is a bunch of key value pairs (separated by =) of the basin integration results such as:
                - atomic charge
                - integration error
                most of the other data is garbage but is parsed anyway for ease of use and a 'just in case' mentality
                """
                if "Results of the basin integration:" in line:
                    line = next(f)
                    while line.strip():
                        for match in re.finditer(patterns.AIMALL_LINE, line):
                            tokens = match.group().split("=")
                            try:
                                self.integration_data[
                                    tokens[0].strip()
                                ] = float(tokens[-1])
                            except ValueError:
                                print(f"Cannot convert {tokens[-1]} to float")
                        line = next(f)
                """
                Following this line is 3 lines we can skip followed by the multipoles
                each multipole is labelled as Q[l,|m|,?] as described such as:
                - Q[0,0] = ...
                - Q[4,4,s] = ...
                
                These will be parsed into the following keys:
                - q00 = ...
                - q44s = ...
                
                All multipoles are parsed even though only hexadecapoles are used by ichor
                again 'just in case'
                """
                if "Real Spherical Harmonic Moments Q[l,|m|,?]" in line:
                    _ = next(f)
                    _ = next(f)
                    _ = next(f)
                    line = next(f)
                    while line.strip():
                        if "=" in line:
                            tokens = line.split("=")
                            try:
                                multipole = (
                                    tokens[0]
                                    .strip()
                                    .replace("[", "")
                                    .replace(",", "")
                                    .replace("]", "")
                                )
                                self.multipoles_data[
                                    multipole.lower()
                                ] = float(tokens[-1])
                            except ValueError:
                                print(f"Cannot convert {tokens[-1]} to float")
                        line = next(f)
                """
                Following this line, we can skip a line and then we have more key value pairs for the iqa data
                Only the E_IQA value is used by ichor but following the 'just in case' mentality, we parse all
                values and store them for access later
                """
                if 'IQA Energy Components (see "2EDM Note"):' in line:
                    _ = next(f)
                    line = next(f)
                    while line.strip():
                        if "=" in line:
                            tokens = line.split("=")
                            try:
                                self.iqa_data[tokens[0].strip()] = float(
                                    tokens[-1]
                                )
                            except ValueError:
                                print(f"Cannot convert {tokens[-1]} to float")
                        line = next(f)

        # this should call the multipoles_data.setter, which should make all the q00,q10, etc. attributes
        # thus, the GeometryData getattr method will not look into __dict__, but __getattribute__ will be used directly
        # self.multipoles_data = raw_multipoles_data
        # after setting all the attributes, we rotate them and modify them as needed.
        if self.parent:
            self.rotate_multipoles()

        # overwrite the initial self.multipoles_data dict because it contains the raw data
        # if not overwritten, the original data from the .int files is
        for multipole_name in constants.multipole_names:
            self.multipoles_data[multipole_name] = getattr(
                self, multipole_name
            )

    @buildermethod
    def read_json(self):
        """A json file is used to contain only the information needed to make the multipole moments. After reading a .int file for the first time,
        the original .int file from AIMALL is renamed to *.int.bak, and the .int file is made into a json file which only contains the information
        that ICHOR needs for later steps. This speeds up reading times if the information from the .int file is needed again."""
        with open(self.json_path, "r") as f:
            int_data = json.load(f)
            self.integration_data = GeometryData(int_data["integration"])
            self.multipoles_data = GeometryData(int_data["multipoles"])
            self.iqa_data = GeometryData(int_data["iqa_data"])
            if "dispersion_data" in int_data.keys():
                self.dispersion_data = GeometryData(
                    int_data["dispersion_data"]
                )
            else:
                self.dispersion_data = GeometryData()

    def write_json(self):
        """Write the .int file in json format that only contains the important information that ICHOR needs for later steps. This speeds up reading times
        if the information needs to be accessed again."""
        int_data = {
            "integration": self.integration_data,
            "multipoles": self.multipoles_data,
            "iqa_data": self.iqa_data,
            "dispersion_data": self.dispersion_data or {},
        }

        with open(self.path, "w") as f:
            json.dump(int_data, f)

    def rotate_multipoles(self):
        """
        Multipoles from AIMAll are calculated in the global spherical frame whereas DL_FFLUX requires
        multipoles in the local spherical frame. To convert from global to local spherical, one must
        convert from global spherical to global cartesian, rotate global cartesian to local cartesian
        then convert local cartesian to local spherical coordinates. This only has to be done once as
        the result of the rotation is stored in the json int file.

        The spherical-cartesian conversion can be found in Appendix E of:
        Stone, Anthony. The Theory of Intermolecular Forces,
        Oxford University Press, Incorporated, 2013.
        """
        self.rotate_dipole()
        self.rotate_quadrupole()
        self.rotate_octupole()
        self.rotate_hexadecapole()

    @cached_property
    def C(self):
        """
        Mills, M.J.L., Popelier, P.L.A., 2014.
        Electrostatic Forces: Formulas for the First Derivatives of a Polarizable,
        Anisotropic Electrostatic Potential Energy Function Based on Machine Learning.
        Journal of Chemical Theory and Computation 10, 3840â€“3856.. doi:10.1021/ct500565g
    
        Eq. 25-30
        """
        from ichor.atoms.calculators.feature_calculator import \
            ALFFeatureCalculator

        atom_inst = self.parent.atoms[self.atom_name]
        x_axis = ALFFeatureCalculator.calculate_x_axis_atom(atom_inst)
        xy_plane = ALFFeatureCalculator.calculate_xy_plane_atom(atom_inst)

        r12 = x_axis.coordinates - atom_inst.coordinates
        r13 = xy_plane.coordinates - atom_inst.coordinates

        mod_r12 = np.linalg.norm(r12)

        r12 /= mod_r12

        ex = r12
        s = sum(ex * r13)
        ey = r13 - s * ex

        ey /= np.sqrt(sum(ey * ey))
        ez = np.cross(ex, ey)
        return np.array([ex, ey, ez])

    # monopole moments (point charges) do not need to be rotated because they are symmetric

    def rotate_dipole(self):
        """Rotates dipole moment from global cartesian to local cartesian. Attributes like self.q11c, self.q11s, etc. are not
        explicitly defined here, but they can be accessed because of the GeometryData __getattr__ implementation, which allows
        accessing dictionary keys as if they were attributes."""
        self.q10, self.q11c, self.q11s = rotate_dipole(
            self.q10, self.q11c, self.q11s, self.C
        )

    def rotate_quadrupole(self):
        """Rotates quadrupole moments from the global to local frame"""
        (
            self.q20,
            self.q21c,
            self.q21s,
            self.q22c,
            self.q22s,
        ) = rotate_quadrupole(
            self.q20, self.q21c, self.q21s, self.q22c, self.q22s, self.C
        )

    def rotate_octupole(self):
        """Rotates octupole moments from the global to local frame"""
        (
            self.q30,
            self.q31c,
            self.q31s,
            self.q32c,
            self.q32s,
            self.q33c,
            self.q33s,
        ) = rotate_octupole(
            self.q30,
            self.q31c,
            self.q31s,
            self.q32c,
            self.q32s,
            self.q33c,
            self.q33s,
            self.C,
        )

    def rotate_hexadecapole(self):
        """Rotates hexadecapole moments from the global to local frame"""
        (
            self.q40,
            self.q41c,
            self.q41s,
            self.q42c,
            self.q42s,
            self.q43c,
            self.q43s,
            self.q44c,
            self.q44s,
        ) = rotate_hexadecapole(
            self.q40,
            self.q41c,
            self.q41s,
            self.q42c,
            self.q42s,
            self.q43c,
            self.q43s,
            self.q44c,
            self.q44s,
            self.C,
        )

    def get_dispersion(self) -> Optional[float]:
        # TODO: THIS DOES NOT NEED TO BE HERE because the pandora directory might not exist. NEED TO PASS in a path from where to get dispersion will be the proper library implementation.
        from ichor.files.pandora import PandoraDirectory

        pandora_path = self.path.parent.parent / PandoraDirectory.dirname
        if pandora_path.exists():
            pandora_dir = PandoraDirectory(pandora_path)
            if pandora_dir.morfi.mout.exists():
                interaction_energy = pandora_dir.morfi.mout[
                    self.atom_name
                ].interaction_energy
                self.dispersion_data["dispersion"] = interaction_energy
                self.write_json()
                return interaction_energy
            raise FileNotFoundError(
                f"Cannot find 'MorfiOutput' in {pandora_dir}"
            )
        raise FileNotFoundError(
            f"Cannot find 'PandoraDirectory' in {self.path.parent}"
        )

    @cached_property
    def dispersion(self):
        # TODO: Move this to a different file. Dispersion is not in original .int files.
        if (
            self.dispersion_data is not None
            and "dispersion" in self.dispersion_data.keys()
        ):
            return self.dispersion_data["dispersion"]
        try:
            return self.get_dispersion()
        except FileNotFoundError:
            raise AttributeError(
                f"'{self.path}' instance of '{self.__class__.__name__}' has no attribute 'dispersion'"
            )